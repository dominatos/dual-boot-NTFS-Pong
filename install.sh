#!/bin/bash
set -eo pipefail

# install.sh - Interactive installer for Dual-boot NTFS Pong

if [[ $EUID -ne 0 ]]; then
   echo "This script must be run as root (sudo)" 
   exit 1
fi

echo "=========================================="
echo "    Dual-boot NTFS Pong Installer"
echo "=========================================="
echo ""

# 1. Detect Disks
echo "Applying 'lsblk' to show available disks:"
lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL
echo ""

# 2. Prompt for Settings
read -p "Enter NTFS Partition Device (e.g. /dev/sda1): " FTP_DISC
read -p "Enter Mount Point for NTFS (e.g. /mnt/ftp): " FTP_MOUNT_POINT
read -p "Enter Windows System Partition (e.g. /dev/sdc3): " WIN_DEV

# Optional Telegram
echo ""
echo "--- Optional Telegram Settings ---"
read -p "Enter Telegram Bot Token (leave empty to skip): " TG_TOKEN
read -p "Enter Telegram Chat ID (leave empty to skip): " CHAT_ID

CONFIG_FILE="/etc/ntfs-watch.conf"

# 3. Write Config
echo ""
echo "Generating $CONFIG_FILE..."

cat <<EOF > "$CONFIG_FILE"
# Configuration for ntfs-watch-and-repair.sh
# Generated by install.sh on $(date)

# NTFS Partition to Monitor
FTP_DISC="$FTP_DISC"
FTP_MOUNT_POINT="$FTP_MOUNT_POINT"

# Windows System Partition (where grub.cfg is located)
WIN_DEV="$WIN_DEV"

EOF

if [[ -n "$TG_TOKEN" && -n "$CHAT_ID" ]]; then
cat <<EOF >> "$CONFIG_FILE"

# Telegram Notification Settings
TG_TOKEN="$TG_TOKEN"
CHAT_ID="$CHAT_ID"
EOF
    # Inject variables into separate tg_send script if used, OR just rely on env vars
    # Since our main script uses settings directly or calls tg_send, 
    # we should export them in the service or script.
    # The refactored main script sources this file, so variables will be available there.
    # But tg_send is a separate script.
    
    # Let's ensure tg_send uses these if called standalone?
    # Actually, simpler: The main script reads conf.
    # If using standalone tg_send, we might want to update it or pass args.
    # But the project uses `tg_send "$LOG_FILE"`.
    # Let's make sure the main script EXPORTS these for tg_send to see, 
    # OR update tg_send to read this config too?
    # For now, we will assume user edits tg_send OR main script passes them.
    # WAIT: The main script calls `tg_send`. `tg_send` has hardcoded vars at top.
    # Ideally, we should update `tg_send` to allow env var override or source config.
    
    # Modification: Update tg_send script to read config if present
    # We will do this via sed during install!
fi

echo "Configuration saved."

# 4. Install Scripts
BIN_DIR="/usr/local/sbin"
BIN_TG="/usr/local/bin" # tg_send usually goes here

echo "Installing scripts..."
cp ntfs_watch_and_repair.sh "$BIN_DIR/"
chmod +x "$BIN_DIR/ntfs_watch_and_repair.sh"

if [[ -f "tg_send" ]]; then
    cp tg_send "$BIN_TG/"
    chmod +x "$BIN_TG/tg_send"
    
    # Patch tg_send to use config variables if set
    # We replace the hardcoded lines with a check
    sed -i 's/^TG_TOKEN=".*"/TG_TOKEN="${TG_TOKEN:-"xxxx:xxxx"}"/' "$BIN_TG/tg_send"
    sed -i 's/^CHAT_ID=".*"/CHAT_ID="${CHAT_ID:-"xxxxx"}"/' "$BIN_TG/tg_send"
    
    # Prepend config sourcing to tg_send
    # Use a temp file to prepend
    cat <<EOT > /tmp/tg_send_patch
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi
EOT
    # Insert after shebang
    sed -i '2r /tmp/tg_send_patch' "$BIN_TG/tg_send"
    rm /tmp/tg_send_patch
fi

# 5. Install Systemd Units
echo "Installing Systemd units..."
cp ntfs-watch.service /etc/systemd/system/
cp ntfs-watch.timer /etc/systemd/system/

# Reload and Enable
systemctl daemon-reload
echo "Enabling ntfs-watch.timer..."
systemctl enable ntfs-watch.timer
systemctl start ntfs-watch.timer

echo ""
echo "=========================================="
echo "    Installation Complete!"
echo "=========================================="
echo "Config file: $CONFIG_FILE"
echo "Check status: systemctl status ntfs-watch.timer"
echo "coded by: https://github.com/dominatos/"
